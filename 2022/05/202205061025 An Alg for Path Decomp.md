Tags :
Zettel :  20220506-1025
Status : #triage 

-----

# Algorithm for Path Decomposition

**Previous note:** [202205041439 Path Decomposition](202205041439%20Path%20Decomposition.md)

-----

### Questions & thoughts:

#### Definitions and concepts
- Graphs are finite and simple
- Some graphs have boundaries of size $k$ - i.e. they have a set of vertices $1, 2, \dots, k$ 
- Two boundaried graphs can be glued to form a regular graph with the $\bigoplus$ operator - this identifies vertices with the same boundary label.

**An homeomorphic embedding** of a graph $G_1=(V_1, E_1)$ in a graph $G_2=(V_2, E_2)$ is an injection from vertices $V_1$ to $V_2$ such that the edges $E_1$ are mapped to disjoint paths of $G_2.$ 
- These disjoint paths in $G_2$ represent potential _subdivisions_ of the edges of $G_1.$ 
- The set of homeomorphic embeddings between graphs gives a partial order called the _topological order._

**A lower ideal** $\mathcal{J}$ in a partial order $(\mathcal{U},\geq)$ is a subset of $\mathcal{U}$ such that if $X\in\mathcal{J}$ and $X\geq Y$ then $Y\in\mathcal{J}.$ The _obstruction set_ for $\mathcal{J}$ is the set of minimal elements of $\mathcal{U}\setminus\mathcal{J}.$

**A path-decomposition** of a graph $G=(V,E)$ is a sequence $X_1, X_2,\dots,X_r$ of subsets of $V$ that satisfy the following three conditions:
1. $\bigcup_{1\leq i\leq r}X_i=V,$
2. for every edge $(u,v)\in E,$ there exists an $X_i$ such that $u\in X_i$ and $v\in X_i$ and 
3. for $1\leq i < j < k \leq r,$ $X_i\cap X_k\subseteq X_j.$

**The pathwidth of a path decomposition** $X_1, X_2, \dots, X_r$ is $\textrm{max}_{1\leq i \leq r}|X_i|-1.$ The pathwidth of a graph $G$ is the minimum pathwidth over all path-decompositions of $G.$

It can be noted that the family of graphs of pathwidth at most $t$ is a lower ideal in the topological (and minor) order. Further, those graphs with order $n$ will have at most $nt-(t^2+t)/2$ edges.

Let $B_h$ denote the **complete binary tree** of height $h$ of order $2^h-1.$ Let $h(t)$ be the minimum value of $h$ such that $B_{h(t)}$ has pathwidth greater than $t.$ Let $f(t)$ be the **number of vertices** in $B_{h(t)}.$ To obtain a bound for $f(t)$, $B_{h(t)}$ must contain at least one obstruction of pathwidth $t.$ It can be shown that **all topological tree obstructions of pathwidth $t$ can be recursively generated by the following rules:**
1. The single-edge tree $K_2$ is the only obstruction of pathwidth 0.
2. If $T_1, T_2$ and $T_3$ are any 3 tree obstructions for pathwidth $t,$ then the tree $T$ consisting of a new degree 3 vertex attached to any of $T_1, T_2$ or $T_3$ is a tree obstruction for pathidth $t+1.$

From this characterisation, we see that the orders the tree obstructions of pathwith $t$ are precisely $(5\cdot3^t-1)/2$ (e.g. orders 2, 7, 22 and 57 for pathwidth $t=0,1,2,3$). We can easily embed at least one of the tree obstructions for pathwidth $t$ in the complete binary tree of height $2t+2$ - hence, the complete binary tree of order $f(t)=2^{2t+2}-1$ has pathwidth greater than $t.$

Using this bound on $f(t),$ we can now examine the main result of the paper.

**Theorem:** Let $H$ be an arbitrary, undirected graph and let $t$ be a positive integer. One of the following must hold:
1. The pathwidth of $H$ is at most $f(t)-1.$
2. $H$ can be factored, i.e. $H=A\bigoplus B$ where $A$ and $B$ are boundaried graphs with boundary size $f(t)$ and the pathwidth of $A$ is greater than $t$ and less than $f(t).$ 

**Proof.**
If we find an homeomorphic embedding of the _guest tree_ $B_{h(t)}$ in the _host graph_ $H,$ we know that the pathwidth of $H$ is greater than $t.$ While searching for such an embedding, we work with a partial embedding - we refer to vertices of the guest tree as tokens, which can be either _placed_ or _unplaced_ meaning they have or have not been mapped to vertices of $H$ in the existing partial embedding. A vertex $v$ of $H$ is _tokened_ if a token maps it to $v.
 At most a single token can be placed on a vertex of $H$ at a given time. We recursively label the tokens using the following rules:
 1. The root token is labelled by the empty string $\lambda,$
 2. The left child token and right child token of a height $h$ parent token $P=b_1b_2\dots b_h$ are labelled $P\cdot 1$ and $P\cdot 0$ respectively.
Now, let $P[i]$ be the set of vertices of $H$ with a token at time $i.$ The sequence $P[0], P[1], \dots, P[s]$ describes a path-decomposition either of the entirety of $H$ or of a factor $A$ satisfying the conditions of the theorem. In the case of the second outcome of the theorem, the boundary of the factor $A$ is indicated by $P[s].$

The placement algorithm is as follows. Initially, consider every vertex of $H$ being coloured blue. Through the algorithm, a vertex of $H$ is coloured red when a token is placed on it and remains red if the token is removed. Only blue vertices can be tokened, meaning a vertex can be tokened only once.

```
function GrowTokenTree:
	if root token l is not placed on H then:
		arbitrarily place l on a blue vertex of H
	endif
	
	while there is a vertex u in H with a token T and a blue neighbour v and token T has an unplaced child T.b do
		place token T.b on v
	endwhile
	return {tokened vertices of H}

program PathDecompositionOrSmallFactor:
	i<-0
	P[i] <- call GrowTokenTree
	while not |P[i]|=f(t) and H has blue vertices do:
		select a token T with untokened children
		remove T from H
		if T had one tokened child then
			replace all tokens T.b.S with T.S
		endif
	endwhile
	i<-i+1
	P[i] <- call GrowTokenTree
	enduntil
	done

```

Some properties of the algorithm:
1. The root token must be placed (step 1 of fn. GrowTokenTree) at most once for each component of H;
2. The GrowTokenTree fn. only returns when $B_{h(t)}$ has been embedded in $H$ or all parent tokens of degree less than have no blue neighbours;
3. The algorithm will terminate since, during each iteration of the while loop in the program PathDecompositionOrSmallFactor, a tokened red vertex becomes untokened and this can happen at most $n$ times (where $n$ is the order of the host $H.$)

Because tokens are placed only on blue vertices and removed only from red vertices, it follows that the interpolation property of a path-decomposition is satisfied. Suppose the alg terminates at time $s$ with all vertices coloured red - to see the sequence of vertex sets $P[0], P[1], \dots, P[s]$ represents a path-decomposition of $H,$ it remains only to show that for each edge $(u,v)$ of $H$ there is a time $i$ where both vertices $u$ and $v$ are in some $P[i].$ Suppose that vertex $u$ is tokened first and untokened before $v$ is tokened, but vertex $u$ can be untokened only if all neighbours (including, in particular, vertex $v$) are coloured red. Hence, at some $P[i],$ both $u$ and $v$ are tokened.

Suppose the alg terminates with all tokens placed. The argument above establishes that the subgraph $A$ of $H$ induced by the red vertices with boundary set $P[s]$ has pathwidth at most $f(t).$ To complete the proof, we argue that - in this case - the sequence of token placements establishes that $A$ contains a sub-division of $B_{h(t)}$ and hence must have pathwidth greater than $t.$ Because the GrowTokenTree function only attaches pendant tokens to parent tokens, we need only observe that the operation in the if statement inside the while loop in the program PathDecompositionOrSmallFactor subdivides the edge between $T$ and its parent. QED


-----
 
**Consider:** It can be shown that the above algorithm `PathDecompositionOrSmallFactor` runs in $O(n)$ on a graph $G$ to determine either that the pathwidth of the graph is greater than an input integer $t$ or a path-decomposition of width at most $f(t).$ Can we therefore use this algorithm before using our equation generation procedure to open the procedure up to wider graph classes?


**Source:** [Kevin Cattell, Michael J. Dinneen, Michael R. Fellows, A Simple Linear-Time Algorithm for Finding Path-Decompositions of Small Width](https://arxiv.org/pdf/math/9410211.pdf)


**Reference:** 
